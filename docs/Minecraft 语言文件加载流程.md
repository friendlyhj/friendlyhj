# Minecraft 语言文件加载流程

> 本篇仅针对 Minecraft 1.12.2

Minecraft 读取语言文件后会形成一个对照表 (`Map<String, String>`)，根据传入的语言文件 key 返回正确的翻译后的文本。服务器只把语言文件 key 传给客户端，客户端根据这个 key 和设定语言显示正确的内容。例如石头的语言文件 key 是 `tile.stone.name`，在中国的张三的电脑上会被翻译成石头，而在美国的 John 的电脑上就会翻译成 Stone。但当翻译没有做完时，我们就能发现缺翻译时的行为：如果一个语言文件 key 没有提供指定语言的翻译，则会提供英文结果。

但这个对照表是非常简单的，仅仅是一个字符串与另一个字符串之间的字典，这个字典并不关心当前使用的是什么语言。那么 Minecraft 是如何从一堆语言文件中构建出满足以上条件的对照表呢？

## 加载流程

1.12.2 处于 Minecraft 新旧交替的分界点，往后的 1.13 的扁平化大改了游戏底层，1.12 画的数据包的饼最后只做了自定义合成表，数据包也到 1.13 才初见成型。语言文件系统也体现了新旧交替。1.12.2 中 Minecraft 其实保存了两份对照表，分别在 LanguageMap (`net.minecraft.util.text.translation.LanguageMap`) 和 Locale (`net.minecraft.client.resources.Locale`) 两个类中。对于这两个类的使用，区别在于前者服务端和客户端都能用，而后者是客户端限定。物品、方块的名称翻译用的是前者，而推荐使用的是后者。

### LanguageMap

LanguageMap 的加载仅读取英文语言文件，而且读取的语言文件是从原版/模组 jar 中解压出来的，资源包是无法干预的。毕竟资源包是客户端才有，而 LanguageMap 服务端也有，服务端不能访问资源包。

LanguageMap 的存在是，在全英文的服务端日志中把 `tile.stone.name` 这样的语言文件 key 换成 `Stone` 这样的更直观的名称。

原版的写法是，仅读取原版 jar 的 `en_us.lang` 文件，逐行读取，如果一行的开头不是 `#`（是 `#` 开头的为注释，忽略），将该行的内容，等号前面的作为 key，后面的作为 value 存入对照表中。

Forge 修改了上述行为，游戏加载时还会读取模组的英文语言文件，以及在第一行加上 `#PARSE_ESCAPES` 能使语言文件按照 java properties 格式解析。

### Locale

Locale 是客户端才有的，它的加载使用了资源包系统，资源包便可以干预了。它是先读取各个模组的英文语言文件，再读取当前语言的语言文件（当然当前语言是英文的话就不用了）。当读取完英文语言文件后，`tile.stone.name` 这个 key 就会对应 Stone，之后再读取中文语言文件时，这个 key 对应的值会被替换成石头。那如果没有中文翻译，原来的英文便不会被覆盖，也就实现了没有对应语言的翻译时显示英文的目标。

解析语言文件的内容的行为与 LanguageMap 相同，也是按等号分割字符串。

资源重载时（F3 + T、修改资源包列表、修改语言设置等）会重新加载 Locale。

## 拷贝

但是这里有一个问题，物品、方块的翻译使用的 LanguageMap 加载时只读取了英文语言文件，而且不使用资源包。但实际情况却是能用别的语言，也能用资源包修改啊。

在 Locale 加载完成后，会把 Locale 保存的对照表拷贝给 LanguageMap。这样 LanguageMap 的内容也是根据资源包和当前语言构建出的了，也会在资源重载时刷新。

## 总结

Minecraft 语言文件的加载分为三步。

* 在游戏预加载时，读取原版/模组 jar 里的英文语言文件，存入 LanguageMap 中
* 在资源加载与重载时，读取资源包的英文和当前语言的语言文件，当前语言的翻译会覆盖英文翻译，存入 Locale 中
* 将 Locale 的内容拷贝给 LanguageMap 中

在客户端中，语言文件被加载了两次，还有一次拷贝操作。这很明显是多余的，翻译系统不需要有两个。在更高的版本便改成了一个，服务端仅读取 jar 里的英文语言文件，客户端也仅读取资源包的内容。
